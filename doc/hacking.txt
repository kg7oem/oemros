This is documentation for people who want to work on the oemros source code.

Objects

This project defines a base object type with the following features:

  * Automatic memory management with reference counting via smart pointers
  * Objects have a member with a string of their type name
  * A constructor exists with a common name as a class method

There are restrictions on the objects as well:

  * A class that can instantiate an object can't be extended; all objects
    are leafs in the inheritance hierarchy.

There are macros to define three different types of classes:

  * OBJECT() defines a class that can be instantiated but can't be extended
  * ABSTRACT() defines a class that can be extended by OBJECT()
  * MIXIN() defines a class that can be used by any class including OBJECT()
    or ABSTRACT() based ones.

Each OBJECT() or ABSTRACT() from this system has three types associated with
it. For instance if there is an OBJECT(example) then the following type names
are defined:

  1. The class name; "example"
  2. A std::shared_ptr wrapped version with a prefix of _s; "example_s"
  2. A std::weak_ptr wrapped version with a prefix of _w; "example_w"

or to put it another way, OBJECT(example) expands out to roughly:

  class example { };
  using example_s = std::shared_ptr<example>;
  using example_w = std::weak_ptr<example>;


Module lifecycle

  0. Modules are loaded and bootstrapped in thread 0
  1. New thread is started that will be exclusive to the module
  2. The constructor specified in the module info is called in the new thread
  3. The newly constructed module will have the will_start() method invoked
  4. The newly constructed thread will enter into the module's runloop
  5. The newly constructed module will have the did_start() method invoked
     inside the context of the runloop.
